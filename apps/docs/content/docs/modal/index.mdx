---
title: Introduction
description: Type-safe modal management for React
---

# Modal

A lightweight, type-safe modal management library for React with support for:

- **Type-safe modals** with input/output generics
- **Builder API** with fluent `.input()`, `.output()`, `.template()`, `.lazy()` methods
- **Lazy loading** for code-splitting modals
- **Position & size management** for draggable/resizable modals
- **Z-index management** with bringToFront, sendToBack, moveUp, moveDown

## Installation

```bash
npm install @jlnstack/modal
```

## Quick Start

### 1. Create a Modal

Use the `modal` builder to define type-safe modals:

```tsx
import { modal } from "@jlnstack/modal";

// Simple modal with typed input
export const confirmModal = modal
  .input<{ title: string; message: string }>()
  .output<boolean>()
  .create((input, { resolve, close }) => (
    <div className="modal">
      <h2>{input.title}</h2>
      <p>{input.message}</p>
      <button onClick={() => resolve(true)}>Confirm</button>
      <button onClick={() => close()}>Cancel</button>
    </div>
  ));
```

### 2. Set up the Provider

```tsx
import { createModalManager } from "@jlnstack/modal";
import { ModalProvider, ModalOutlet } from "@jlnstack/modal/react";

const manager = createModalManager();

function App() {
  return (
    <ModalProvider manager={manager}>
      <YourApp />
      <ModalOutlet />
    </ModalProvider>
  );
}
```

### 3. Open Modals

```tsx
import { useModal } from "@jlnstack/modal/react";
import { confirmModal } from "./modals";

function DeleteButton() {
  const modal = useModal(confirmModal);

  const handleDelete = async () => {
    const confirmed = await modal.open({
      title: "Delete Item",
      message: "Are you sure you want to delete this item?",
    });

    if (confirmed) {
      // User clicked confirm
      deleteItem();
    }
  };

  return <button onClick={handleDelete}>Delete</button>;
}
```

## Modal Builder API

The `modal` builder provides a fluent API for creating type-safe modals:

```tsx
import { modal } from "@jlnstack/modal";

// Define input and output types
const myModal = modal
  .input<{ name: string }>()  // Type the input
  .output<string>()           // Type the resolved value
  .create((input, options) => <MyComponent {...input} {...options} />);
```

### With Default Values

Provide default values to make input fields optional:

```tsx
const greetModal = modal
  .input<{ name: string; greeting: string }>()
  .create(
    (input) => <p>{input.greeting}, {input.name}!</p>,
    {
      defaultValues: {
        modal: { greeting: "Hello" }  // greeting is now optional
      }
    }
  );

// Can open without greeting
greetModal.open({ name: "World" });
```

### With Templates

Wrap modals in reusable templates:

```tsx
const dialogModal = modal
  .output<boolean>()
  .template(({ modal, close, resolve }) => (
    <div className="dialog-wrapper">
      <div className="dialog-content">{modal}</div>
      <div className="dialog-footer">
        <button onClick={() => resolve(false)}>Cancel</button>
        <button onClick={() => resolve(true)}>OK</button>
      </div>
    </div>
  ))
  .create((input) => <p>{input.message}</p>);
```

### Lazy Loading

Use `.lazy()` to code-split modals and load them on demand:

```tsx
// modals/settings.tsx - this file is only loaded when the modal opens
import type { ModalComponentOptions } from "@jlnstack/modal";

type Props = { userId: string };

export default function SettingsModal({ userId, close, resolve }: Props & ModalComponentOptions<void>) {
  return (
    <div className="modal">
      <h2>Settings for {userId}</h2>
      <button onClick={close}>Close</button>
    </div>
  );
}
```

```tsx
// modals/index.ts - define the lazy modal
import { modal } from "@jlnstack/modal";

export const modals = {
  // Eager - loaded immediately with the registry
  confirm: modal.input<{ message: string }>().create(/* ... */),

  // Lazy - only loaded when first opened
  settings: modal
    .input<{ userId: string }>()
    .lazy(() => import("./settings")),
};
```

The component is loaded via dynamic import when the modal is first opened. You can provide a custom fallback:

```tsx
const settingsModal = modal
  .input<{ userId: string }>()
  .lazy(
    () => import("./settings"),
    { fallback: <LoadingSpinner /> }
  );
```

