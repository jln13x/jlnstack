---
title: Basic Usage
description: Learn how to use useFilter and its reactive hooks
---

# Basic Usage

The `useFilter` hook is the primary way to manage filter state in React. It returns a **stable reference** by default — meaning the returned object won't change between renders. Reactivity is opt-in through hooks.

## Defining Filters

First, define your filter schema using `defineFilters`:

```ts
import { defineFilters, stringFilter, booleanFilter, numberFilter } from "@jlnstack/filter"

export const userFilters = defineFilters({
  name: stringFilter({ label: "Name", operators: ["eq", "contains"] }),
  verified: booleanFilter({ label: "Verified" }),
  age: numberFilter({ label: "Age", min: 0, max: 120 }),
})
```

## Using useFilter

The `useFilter` hook creates a filter store from your schema:

```tsx
import { useFilter } from "@jlnstack/filter/react"
import { and, condition } from "@jlnstack/filter"
import { userFilters } from "./filters"

function UsersPage() {
  const filter = useFilter(userFilters, {
    defaultFilter: and(
      condition("verified", true)
    ),
    onFilterChange: (filter) => {
      console.log("Filter changed:", filter)
    },
  })

  return (
    <div>
      <button onClick={() => filter.addCondition({ field: "verified", value: false })}>
        Add Unverified Filter
      </button>
      <button onClick={filter.reset}>Reset</button>
    </div>
  )
}
```

### Options

| Option | Type | Description |
|--------|------|-------------|
| `defaultFilter` | `GroupInput<Schema>` | Initial filter expression |
| `onFilterChange` | `(filter: Group) => void` | Callback when filters change |

### Returned API

| Property | Description |
|----------|-------------|
| `getFilter()` | Get the current filter tree |
| `getFilterById(id)` | Get a specific filter/group by ID |
| `addCondition({ field, value, groupId? })` | Add a filter condition |
| `addGroup({ operator, groupId? })` | Add a nested group |
| `updateCondition({ id, value })` | Update a condition's value |
| `setOperator({ id, operator })` | Change a group's operator |
| `removeFilter({ id })` | Remove a condition or group |
| `setFilter(expression)` | Replace the entire filter |
| `reset()` | Reset to default filter |
| `Filter` | Render prop component |
| `useFilter()` | Hook to subscribe to filter changes |
| `useFilterById(id)` | Hook to subscribe to a specific filter |
| `useFilterDefinitions()` | Hook to get filter definitions |
| `schema` | The filter schema |
| `rootId` | The root group's ID |

## The Filter Component

The `Filter` component provides reactive access to render filter inputs:

```tsx
function FilterPanel() {
  const filter = useFilter(userFilters)

  return (
    <div>
      <filter.Filter
        name="name"
        render={({ value, onValueChange, definition }) => (
          <div>
            <label>{definition.label}</label>
            <input
              value={value?.value ?? ""}
              onChange={(e) =>
                onValueChange({ operator: "contains", value: e.target.value })
              }
            />
          </div>
        )}
      />

      <filter.Filter
        name="verified"
        render={({ value, onValueChange }) => (
          <select
            value={value === undefined ? "" : String(value)}
            onChange={(e) =>
              onValueChange(e.target.value === "" ? undefined : e.target.value === "true")
            }
          >
            <option value="">All</option>
            <option value="true">Verified</option>
            <option value="false">Unverified</option>
          </select>
        )}
      />
    </div>
  )
}
```

### Render Function Props

| Prop | Type | Description |
|------|------|-------------|
| `name` | `string` | The filter key |
| `type` | `string` | The filter type id (e.g., "string", "boolean") |
| `value` | `Value \| undefined` | Current filter value |
| `onValueChange` | `(value) => void` | Update the filter value |
| `definition` | `FilterDef` | Full filter definition with options |

## Reactive Hooks

### useFilter (reactive)

Subscribe to filter tree changes:

```tsx
function FilterSummary() {
  const filter = useFilter(userFilters)
  const currentFilter = filter.useFilter()

  return (
    <div>
      {currentFilter.filters.length} conditions active
    </div>
  )
}
```

### useFilterById

Subscribe to a specific filter by ID:

```tsx
function ConditionEditor({ conditionId }) {
  const filter = useFilter(userFilters)
  const condition = filter.useFilterById(conditionId)

  if (!condition) return null

  return <div>Editing: {JSON.stringify(condition)}</div>
}
```

### useFilterDefinitions

Get an array of all filter definitions:

```tsx
function AddFilterMenu() {
  const filter = useFilter(userFilters)
  const definitions = filter.useFilterDefinitions()

  return (
    <select
      onChange={(e) => {
        const field = e.target.value
        if (field) {
          filter.addCondition({ field, value: undefined })
        }
      }}
    >
      <option value="">Add filter...</option>
      {definitions.map((def) => (
        <option key={def.name} value={def.name}>
          {def.label ?? def.name}
        </option>
      ))}
    </select>
  )
}
```

## Why Stable by Default?

The `useFilter` hook returns a stable object reference. This design choice:

1. **Prevents unnecessary re-renders** — Components using only imperative methods won't re-render.
2. **Optimizes performance** — Only components using reactive hooks re-render on changes.
3. **Gives you control** — Choose where you need reactivity.

```tsx
// ❌ This component won't re-render when filters change
function ExportButton() {
  const filter = useFilter(userFilters)
  return (
    <button onClick={() => exportData(filter.getFilter())}>
      Export
    </button>
  )
}

// ✅ This component re-renders when filters change
function ActiveFilterCount() {
  const filter = useFilter(userFilters)
  const currentFilter = filter.useFilter()
  return <span>{currentFilter.filters.length} active filters</span>
}
```
