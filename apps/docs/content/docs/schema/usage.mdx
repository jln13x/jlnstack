---
title: Usage
description: How to use versioned schemas with migrations
---

# Usage

## Creating a Versioned Schema

Use `createVersionedSchema` to define your current schema with migration paths from older versions.

```ts
import { createVersionedSchema } from "@jlnstack/schema"
import type { VersionMigration } from "@jlnstack/schema"
import { z } from "zod"

// Define your schemas
const v1Schema = z.object({ name: z.string() })
const v2Schema = z.object({ name: z.string(), age: z.number() })
const v3Schema = z.object({
  name: z.string(),
  age: z.number(),
  email: z.string().optional(),
})

// Define typed migrations
const v1Migration: VersionMigration<{ name: string }> = {
  version: "1",
  schema: v1Schema,
  up: (v1) => ({ name: v1.name, age: 0 }),
}

const v2Migration: VersionMigration<{ name: string; age: number }> = {
  version: "2",
  schema: v2Schema,
  up: (v2) => ({ ...v2, email: undefined }),
}

// Create the versioned schema
const userSchema = createVersionedSchema({
  version: "3",
  schema: v3Schema,
  migrations: [v1Migration, v2Migration],
})
```

## How It Works

```
Input: { version: "1", data: { name: "John" } }
         │
         ▼
    Read version: "1"
         │
         ▼
    Validate against v1 schema
         │
         ▼
    v1.up() → { name: "John", age: 0 }
         │
         ▼
    v2.up() → { name: "John", age: 0, email: undefined }
         │
         ▼
    Validate against v3 (current)
         │
         ▼
    Return { version: "3", data: { name: "John", age: 0, email: undefined } }
```

1. **Read version** — Extract version from `{ version, data }` wrapper
2. **Validate** — Validate data against that version's schema
3. **Migrate** — Run each migration's `up` function in order
4. **Validate final** — Validate result against current schema
5. **Return** — Return wrapped with current version

## Legacy (Unversioned) Data

When migrating from an existing system without versioning, use the `legacy` option:

```ts
const userSchema = createVersionedSchema({
  version: "2",
  schema: v2Schema,
  migrations: [v1Migration],
  legacy: "1", // treat unversioned data as v1
})

// Unversioned input: { name: "John" }
// Treated as v1: { version: "1", data: { name: "John" } }
// Migrated to v2: { version: "2", data: { name: "John", age: 0 } }
```

## With @jlnstack/cookies

```ts
import { createCookie, browserCookie } from "@jlnstack/cookies/browser"
import { createVersionedSchema } from "@jlnstack/schema"
import { z } from "zod"

const preferencesSchema = createVersionedSchema({
  version: "2",
  schema: z.object({
    theme: z.enum(["light", "dark", "system"]),
    fontSize: z.number(),
  }),
  migrations: [
    {
      version: "1",
      schema: z.object({ theme: z.enum(["light", "dark"]) }),
      up: (v1) => ({ theme: v1.theme, fontSize: 16 }),
    },
  ],
  legacy: "1",
})

const preferencesCookie = createCookie({
  name: "preferences",
  schema: preferencesSchema,
  ...browserCookie("preferences"),
})
```

## Async Migrations

Both schema validation and migration functions can be async:

```ts
const v1Migration: VersionMigration<{ id: string }> = {
  version: "1",
  schema: v1Schema,
  up: async (v1) => {
    const userData = await fetchUserData(v1.id)
    return { ...v1, ...userData }
  },
}
```

## API Reference

### `createVersionedSchema(config)`

Creates a Standard Schema that handles versioned data with migrations.

**Config:**

| Option | Type | Description |
| --- | --- | --- |
| `version` | `string` | Current version identifier |
| `schema` | `StandardSchemaV1` | Current schema (source of truth) |
| `migrations` | `VersionMigration[]` | Migrations from older versions |
| `legacy` | `string` | Version to assign to unversioned data |

**Returns:** `StandardSchemaV1<unknown, VersionedData<T>>`

### `VersionMigration<T>`

```ts
type VersionMigration<T> = {
  version: string
  schema: StandardSchemaV1<unknown, T>
  up: (data: T) => unknown | Promise<unknown>
}
```

### `VersionedData<T>`

```ts
type VersionedData<T> = {
  version: string
  data: T
}
```
