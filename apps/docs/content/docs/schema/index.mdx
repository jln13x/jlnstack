---
title: Introduction
description: Schema versioning and migration utilities for evolving data structures
---

# Schema

Schema versioning and migration utilities for handling evolving data structures. Works with any [Standard Schema](https://github.com/standard-schema/standard-schema) compatible library.

> **Note:** This is not a schema validation library. Use Zod, Valibot, Effect Schema, or any other Standard Schema compatible library for that. This package helps you handle versioning and migrations when your schemas evolve over time.

## Why Schema?

- **Explicit versioning** — Data includes version identifiers for reliable migration paths.
- **Works with existing libraries** — Use with Zod, Valibot, ArkType, or any Standard Schema compatible library.
- **Type-safe migrations** — Full TypeScript inference for migration functions.
- **Legacy support** — Migrate from unversioned data to versioned format.

## The Problem

When you store validated data (cookies, localStorage, databases), the schema may change over time:

```ts
// v1: Initial schema
{ name: string }

// v2: Added age field
{ name: string, age: number }

// v3: Added optional email
{ name: string, age: number, email?: string }
```

Old stored data needs to be read and migrated to the current format. This package provides explicit versioning and migration chains to handle that reliably.

## Quick Example

```ts
import { createVersionedSchema } from "@jlnstack/schema"
import { z } from "zod"

const userSchema = createVersionedSchema({
  version: "3",
  schema: z.object({
    name: z.string(),
    age: z.number(),
    email: z.string().optional(),
  }),
  migrations: [
    {
      version: "1",
      schema: z.object({ name: z.string() }),
      up: (v1) => ({ name: v1.name, age: 0 }),
    },
    {
      version: "2",
      schema: z.object({ name: z.string(), age: z.number() }),
      up: (v2) => ({ ...v2, email: undefined }),
    },
  ],
  legacy: "1", // treat unversioned data as v1
})

// Input:  { version: "1", data: { name: "John" } }
// Output: { version: "3", data: { name: "John", age: 0, email: undefined } }
```

## Data Format

All versioned data uses this wrapper format:

```ts
{
  version: string,
  data: T
}
```

This makes the version explicit and allows reliable migration paths.
