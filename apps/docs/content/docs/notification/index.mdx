---
title: Introduction
description: Type-safe notification/inbox management
---

# Notification

<PackageInfo name="@jlnstack/notification" />

A lightweight, type-safe notification/inbox management library with support for:

- **Type-safe notifications** with Standard Schema support (zod, valibot, arktype)
- **Adapter-based storage** for flexible persistence (in-memory, Drizzle, etc.)
- **Full type inference** from your notification schemas

## Installation

```bash
npm install @jlnstack/notification
```

## Quick Start

### 1. Define Notification Types

Use Standard Schema libraries like zod to define your notification types:

```ts
import { z } from "zod";
import { createNotificationManager, createMemoryAdapter } from "@jlnstack/notification";

const manager = createNotificationManager({
  types: {
    message: z.object({
      from: z.string(),
      preview: z.string(),
    }),
    alert: z.object({
      severity: z.enum(["info", "warning", "error"]),
    }),
    system: z.object({}),
  },
  adapter: createMemoryAdapter(),
});
```

### 2. Send Notifications

The `send` method is fully type-safe based on your schema definitions:

```ts
// Type-safe - data must match the schema
await manager.send("message", {
  userId: "user_123",
  title: "New message from John",
  data: { from: "john", preview: "Hey there!" },
});

await manager.send("alert", {
  userId: "user_123",
  title: "System Warning",
  data: { severity: "warning" },
});
```

### 3. Query Notifications

```ts
// List all unread notifications for a user
const unread = await manager.list({
  userId: "user_123",
  read: false,
});

// Get unread count
const count = await manager.unreadCount("user_123");

// Filter by notification type
const alerts = await manager.list({
  userId: "user_123",
  type: "alert", // Type-safe: only "message" | "alert" | "system" allowed
});
```

### 4. Manage Notifications

```ts
// Mark as read
await manager.markAsRead("notification_id");
await manager.markAllAsRead("user_123");

// Archive
await manager.archive("notification_id");
await manager.unarchive("notification_id");

// Delete
await manager.delete("notification_id");
await manager.deleteMany({ userId: "user_123", read: true });
```

## Hooks

Use the `onSend` hook to trigger side effects when notifications are sent:

```ts
const manager = createNotificationManager({
  types: {
    message: z.object({ from: z.string() }),
    alert: z.object({ severity: z.enum(["info", "warning", "error"]) }),
  },
  adapter: createMemoryAdapter(),
  onSend: async (notification) => {
    // Send email for alerts
    if (notification.type === "alert" && notification.data.severity === "error") {
      await sendEmail({
        to: notification.userId,
        subject: notification.title,
      });
    }

    // Send push notification
    await sendPushNotification(notification);
  },
});
```

The hook receives the full notification object after it's been stored, including the generated `id` and `createdAt` fields.

## Plain Types (No Schema)

You can also use plain TypeScript types without a schema library:

```ts
type MessageData = { from: string; preview: string };
type AlertData = { severity: "info" | "warning" | "error" };

const manager = createNotificationManager({
  types: {
    message: {} as MessageData,
    alert: {} as AlertData,
  },
  adapter: createMemoryAdapter(),
});
```

## API Reference

### `createNotificationManager(options)`

Creates a notification manager instance.

**Options:**

| Option | Type | Description |
|--------|------|-------------|
| `types` | `Record<string, Schema>` | Notification type definitions |
| `adapter` | `NotificationAdapter` | Storage adapter |
| `onSend` | `(notification) => void \| Promise<void>` | Hook called after sending |

**Returns:** `NotificationManager`

### NotificationManager Methods

| Method | Description |
|--------|-------------|
| `send(type, options)` | Send a new notification |
| `get(id)` | Get a notification by ID |
| `list(filter?)` | List notifications with optional filtering |
| `count(filter?)` | Count notifications matching filter |
| `unreadCount(userId)` | Get unread count for a user |
| `markAsRead(id)` | Mark a notification as read |
| `markManyAsRead(ids)` | Mark multiple notifications as read |
| `markAllAsRead(userId)` | Mark all notifications for a user as read |
| `archive(id)` | Archive a notification |
| `unarchive(id)` | Unarchive a notification |
| `delete(id)` | Delete a notification |
| `deleteMany(filter)` | Delete notifications matching filter |

### Notification Structure

Each notification has the following fields:

```ts
type Notification = {
  id: string;
  userId: string;
  type: string;        // Your defined notification type
  title: string;
  body?: string;
  data: unknown;       // Type-safe based on your schema
  read: boolean;
  archived: boolean;
  createdAt: Date;
  readAt?: Date;
};
```
