import * as fs from "node:fs";
import * as path from "node:path";

export interface TranslationEntry {
  key: string;
  translations: Record<string, string>;
}

export interface ParsedTranslations {
  entries: TranslationEntry[];
  locales: string[];
}

/**
 * Parse a TypeScript translation file.
 *
 * Expects format:
 * ```ts
 * export const login = { en: "Sign in", de: "Anmelden" } as const;
 * ```
 */
export function parseTranslationFile(filePath: string): ParsedTranslations {
  const content = fs.readFileSync(filePath, "utf-8");
  return parseTranslationContent(content);
}

/**
 * Parse TypeScript translation content.
 */
export function parseTranslationContent(content: string): ParsedTranslations {
  const entries: TranslationEntry[] = [];
  const localesSet = new Set<string>();

  // Match: export const KEY = { ... } as const;
  // Use a more robust approach - find export const, then match balanced braces
  const lines = content.split("\n");
  let currentKey: string | null = null;
  let objectBuffer = "";
  let braceCount = 0;
  let inObject = false;

  for (const line of lines) {
    // Check for new export
    const exportMatch = line.match(/export\s+const\s+(\w+)\s*=\s*\{/);
    if (exportMatch && !inObject) {
      currentKey = exportMatch[1] ?? null;
      inObject = true;
      braceCount = 1;
      // Get content after the opening brace
      const afterBrace = line.substring(line.indexOf("{") + 1);
      objectBuffer = afterBrace;

      // Count braces in the rest of the line
      for (const char of afterBrace) {
        if (char === "{") braceCount++;
        else if (char === "}") braceCount--;
      }

      // Check if object ends on same line
      if (braceCount === 0 && currentKey) {
        parseObjectContent(currentKey, objectBuffer, entries, localesSet);
        currentKey = null;
        objectBuffer = "";
        inObject = false;
      }
      continue;
    }

    if (inObject) {
      objectBuffer += "\n" + line;

      // Count braces
      for (const char of line) {
        if (char === "{") braceCount++;
        else if (char === "}") braceCount--;
      }

      if (braceCount === 0 && currentKey) {
        parseObjectContent(currentKey, objectBuffer, entries, localesSet);
        currentKey = null;
        objectBuffer = "";
        inObject = false;
      }
    }
  }

  return {
    entries,
    locales: Array.from(localesSet).sort(),
  };
}

function parseObjectContent(
  key: string,
  objectContent: string,
  entries: TranslationEntry[],
  localesSet: Set<string>,
): void {
  const translations: Record<string, string> = {};

  // Match: locale: "value" - handle escaped quotes properly
  // This regex matches the locale identifier followed by a string value
  const propRegex = /(\w+)\s*:\s*"((?:[^"\\]|\\.)*)"/g;

  let propMatch;
  while ((propMatch = propRegex.exec(objectContent)) !== null) {
    const locale = propMatch[1];
    const rawValue = propMatch[2];

    if (locale && rawValue !== undefined) {
      // Unescape the value
      const value = rawValue.replace(/\\"/g, '"').replace(/\\\\/g, "\\");
      translations[locale] = value;
      localesSet.add(locale);
    }
  }

  if (Object.keys(translations).length > 0) {
    entries.push({ key, translations });
  }
}

/**
 * Generate TypeScript content from parsed translations.
 */
export function generateTranslationContent(
  entries: TranslationEntry[],
  locales: string[],
): string {
  const lines: string[] = [
    "// Auto-generated by @jlnstack/i18n studio",
    "// Do not edit manually",
    "",
  ];

  const sortedEntries = [...entries].sort((a, b) => a.key.localeCompare(b.key));

  for (const entry of sortedEntries) {
    const sortedLocales = [...locales].sort();
    const props = sortedLocales
      .map((locale) => {
        const value = entry.translations[locale] ?? "";
        const escaped = value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        return `  ${locale}: "${escaped}"`;
      })
      .join(",\n");

    lines.push(`export const ${entry.key} = {`);
    lines.push(props);
    lines.push("} as const;");
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Write translations to a TypeScript file.
 */
export function writeTranslationFile(
  filePath: string,
  entries: TranslationEntry[],
  locales: string[],
): void {
  const content = generateTranslationContent(entries, locales);
  const dir = path.dirname(filePath);

  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(filePath, content);
}

/**
 * Update a single translation in an existing file.
 */
export function updateTranslation(
  filePath: string,
  key: string,
  locale: string,
  value: string,
): void {
  const parsed = parseTranslationFile(filePath);

  const entry = parsed.entries.find((e) => e.key === key);
  if (entry) {
    entry.translations[locale] = value;
  } else {
    // Create new entry
    parsed.entries.push({
      key,
      translations: { [locale]: value },
    });
  }

  // Make sure locale is in locales list
  if (!parsed.locales.includes(locale)) {
    parsed.locales.push(locale);
    parsed.locales.sort();
  }

  writeTranslationFile(filePath, parsed.entries, parsed.locales);
}

/**
 * Add a new translation key.
 */
export function addTranslationKey(
  filePath: string,
  key: string,
  translations: Record<string, string>,
): void {
  let parsed: ParsedTranslations;

  if (fs.existsSync(filePath)) {
    parsed = parseTranslationFile(filePath);
  } else {
    parsed = { entries: [], locales: [] };
  }

  // Check if key already exists
  const existing = parsed.entries.find((e) => e.key === key);
  if (existing) {
    throw new Error(`Translation key "${key}" already exists`);
  }

  // Add new entry
  parsed.entries.push({ key, translations });

  // Update locales
  for (const locale of Object.keys(translations)) {
    if (!parsed.locales.includes(locale)) {
      parsed.locales.push(locale);
    }
  }
  parsed.locales.sort();

  writeTranslationFile(filePath, parsed.entries, parsed.locales);
}

/**
 * Delete a translation key.
 */
export function deleteTranslationKey(filePath: string, key: string): void {
  const parsed = parseTranslationFile(filePath);

  const index = parsed.entries.findIndex((e) => e.key === key);
  if (index === -1) {
    throw new Error(`Translation key "${key}" not found`);
  }

  parsed.entries.splice(index, 1);
  writeTranslationFile(filePath, parsed.entries, parsed.locales);
}
