import * as fs from "node:fs";
import * as path from "node:path";

interface LocaleData {
  [key: string]: string;
}

interface MergedTranslations {
  [key: string]: {
    [locale: string]: string;
  };
}

/**
 * Migrate JSON locale files to a single TypeScript file.
 *
 * @example
 * Given:
 *   locales/en.json: { "login": "Sign in", "logout": "Sign out" }
 *   locales/de.json: { "login": "Anmelden", "logout": "Abmelden" }
 *
 * Produces:
 *   export const login = { en: "Sign in", de: "Anmelden" } as const;
 *   export const logout = { en: "Sign out", de: "Abmelden" } as const;
 */
export async function migrate(
  sourcePath: string,
  outputPath: string,
): Promise<void> {
  const resolvedSource = path.resolve(process.cwd(), sourcePath);
  const resolvedOutput = path.resolve(process.cwd(), outputPath);

  // Check if source exists
  if (!fs.existsSync(resolvedSource)) {
    console.error(`Error: Source path does not exist: ${resolvedSource}`);
    process.exit(1);
  }

  const stats = fs.statSync(resolvedSource);
  let jsonFiles: string[];

  if (stats.isDirectory()) {
    // Find all JSON files in directory
    jsonFiles = fs
      .readdirSync(resolvedSource)
      .filter((file) => file.endsWith(".json"))
      .map((file) => path.join(resolvedSource, file));
  } else if (stats.isFile() && resolvedSource.endsWith(".json")) {
    jsonFiles = [resolvedSource];
  } else {
    console.error("Error: Source must be a directory or JSON file");
    process.exit(1);
  }

  if (jsonFiles.length === 0) {
    console.error("Error: No JSON files found");
    process.exit(1);
  }

  // Read and parse all JSON files
  const locales: Map<string, LocaleData> = new Map();

  for (const file of jsonFiles) {
    const locale = path.basename(file, ".json");
    const content = fs.readFileSync(file, "utf-8");

    try {
      const data = JSON.parse(content) as LocaleData;
      locales.set(locale, data);
      console.log(`  Read ${locale}: ${Object.keys(data).length} keys`);
    } catch {
      console.error(`Error: Failed to parse ${file}`);
      process.exit(1);
    }
  }

  // Merge translations by key
  const merged: MergedTranslations = {};
  const allKeys = new Set<string>();

  for (const [locale, data] of locales) {
    for (const key of Object.keys(data)) {
      allKeys.add(key);
      if (!merged[key]) {
        merged[key] = {};
      }
      const value = data[key];
      if (value !== undefined) {
        merged[key][locale] = value;
      }
    }
  }

  // Generate TypeScript output
  const sortedKeys = Array.from(allKeys).sort();
  const lines: string[] = [
    "// Auto-generated by @jlnstack/i18n migrate",
    "// Do not edit manually - run migrate again to update",
    "",
  ];

  for (const key of sortedKeys) {
    const translations = merged[key];
    if (!translations) continue;
    const entries = Object.entries(translations)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([locale, value]) => {
        // Escape special characters in value
        const escaped = value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        return `  ${locale}: "${escaped}"`;
      })
      .join(",\n");

    lines.push(`export const ${sanitizeKey(key)} = {`);
    lines.push(entries);
    lines.push("} as const;");
    lines.push("");
  }

  // Write output
  const outputDir = path.dirname(resolvedOutput);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(resolvedOutput, lines.join("\n"));

  console.log(`\nâœ“ Migrated ${sortedKeys.length} keys to ${resolvedOutput}`);
}

/**
 * Sanitize a translation key to be a valid JS identifier.
 */
function sanitizeKey(key: string): string {
  // Replace dots and other invalid chars with underscores
  let sanitized = key.replace(/[^a-zA-Z0-9_$]/g, "_");

  // Ensure it doesn't start with a number
  if (/^[0-9]/.test(sanitized)) {
    sanitized = "_" + sanitized;
  }

  return sanitized;
}
